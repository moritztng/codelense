package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.31

import (
	"context"
	"encoding/json"
	"fmt"
	"math/rand"
	"strconv"
	"time"

	"github.com/confluentinc/confluent-kafka-go/kafka"
)

// Text is the resolver for the text field.
func (r *queryResolver) Text(ctx context.Context) (string, error) {
	type apiGithubRequest struct {
		Name string
	}
	type githubStoreResult struct {
		Name  string
		Stars uint
	}
	produceTopic := "api_github_requests"
	request, _ := json.Marshal(apiGithubRequest{strconv.Itoa(rand.Intn(100))})
	fmt.Println("start produce")
	r.Producer.Produce(&kafka.Message{
		TopicPartition: kafka.TopicPartition{Topic: &produceTopic, Partition: kafka.PartitionAny},
		Value:          request,
	}, nil)
	r.Producer.Produce(&kafka.Message{
		TopicPartition: kafka.TopicPartition{Topic: &produceTopic, Partition: kafka.PartitionAny},
		Value:          request,
	}, nil)
	fmt.Println("end produce")
	var result githubStoreResult
	for {
		message, err := r.Consumer.ReadMessage(time.Second)
		if err == nil {
			json.Unmarshal(message.Value, &result)
			break
		} else {
			fmt.Println(err)
		}
	}
	return result.Name, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
