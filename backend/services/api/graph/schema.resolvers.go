package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.31

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/confluentinc/confluent-kafka-go/kafka"
	"github.com/google/uuid"
	"github.com/moritztng/codelense/backend/messaging"
	"github.com/moritztng/codelense/backend/services/api/graph/model"
)

// Repositories is the resolver for the repositories field.
func (r *queryResolver) Repositories(ctx context.Context, maxStars int, first int) (*model.Repositories, error) {
	produceTopic := "api_github_requests"
	key := uuid.New().String()
	request, _ := json.Marshal(messaging.ApiGithubRequest{Key: key, MaxStars: uint(maxStars), First: uint(first)})
	r.Producer.Produce(&kafka.Message{
		TopicPartition: kafka.TopicPartition{Topic: &produceTopic, Partition: kafka.PartitionAny},
		Value:          request,
	}, nil)
	var result messaging.GithubStoreResult
	for {
		message, err := r.Consumer.ReadMessage(time.Second)
		if err == nil {
			json.Unmarshal(message.Value, &result)
			break
		} else {
			fmt.Println(err)
		}
	}
	var repositories model.Repositories
	for _, repository := range result.Repositories {
		repositories.Repositories = append(repositories.Repositories, &model.Repository{Owner: repository.Owner, Name: repository.Name, Stars: int(repository.Stars)})
	}
	return &repositories, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
